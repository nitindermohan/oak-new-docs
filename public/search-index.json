[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"\rOakestra lets you deploy your workload on devices of any size. From a small RasperryPi to a cloud instance far away on GCP or AWS. The tree structure enables you to create multiple clusters of resources.\nThe Root Orchestrator manages different clusters of resources. The root only sees aggregated cluster resources. The Cluster orchestrator manages your worker nodes. This component collects the real-time resources and schedules your workloads to the perfect matching device. A Worker is any device where a component called NodeEngine is installed. Each node can support multiple execution environments such as Containers (containerd runtime), MicroVM (containerd runtime), and Unikernels (mirageOS). Did you know?\nSince the stable Accordion release, Oakestra supports both containers and unikernel virtualization targets.\nCreate your first Oakestra cluster Let\u0026rsquo;s start simple with a single node deployment, where all the components are deployed on the same device.\nRequirements\nLinux (Workers only) Docker + Docker compose (Orchestrators only) Cluster Orchestrator and Root Orchestrator machines must be mutually reachable. 1-DOC (1 Device, One Cluster) In this example, we will use a single device to deploy all the components. This is not recommended for production environments, but it is pretty cool for home environments and development.\n0) First, let\u0026rsquo;s export the required environment variables\n## Choose a unique name for your cluster export CLUSTER_NAME=My_Awesome_Cluster ## Come up with a name for the current location export CLUSTER_LOCATION=My_Awesome_Apartment\r1) Clone the repository and move into it using:\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra\r2) Run a local 1-DOC cluster\nsudo -E docker-compose -f run-a-cluster/1-DOC.yaml up\r3) download, untar and install the node engine package\nwget -c https://github.com/oakestra/oakestra/releases/download/v0.4.202/NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; mv NodeEngine NodeEngine_$(dpkg --print-architecture) \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r4) (optional) download and unzip and install the network manager; this enables an overlay network across your services\nwget -c https://github.com/oakestra/oakestra-net/releases/download/v0.4.202/NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r4.1) Edit /etc/netmanager/netcfg.json as follows:\n{ \u0026#34;NodePublicAddress\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THIS DEVICE\u0026gt;\u0026#34;, \u0026#34;NodePublicPort\u0026#34;: \u0026#34;\u0026lt;PORT REACHABLE FROM OUTSIDE, use 50103 as default\u0026gt;\u0026#34;, \u0026#34;ClusterUrl\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;ClusterMqttPort\u0026#34;: \u0026#34;10003\u0026#34; }\r4.2) start the NetManager on port 6000\nsudo NetManager -p 6000 \u0026amp;\r5) start the NodeEngine. Please only use the -n 6000 parameter if you started the network component in step 4. This parameter, in fact, is used to specify the internal port of the network component, if any.\nsudo NodeEngine -n 6000 -p 10100\r( you can use NodeEngine -h for further details )\nM-DOC (M Devices, One Cluster) Now, let\u0026rsquo;s separate the Oakestra components over multiple devices and create a more distributed cluster.\nThe M-DOC deployment enables you to deploy One cluster with multiple worker nodes. The main difference between this deployment and 1-DOC is that the worker nodes might be external here, and there can be multiple of them.\nThe deployment of this kind of cluster is similar to 1-DOC. We first need to start the root and cluster orchestrator. Afterward, we can attach the worker nodes.\n1) On the node you wish to use as a cluster and root orchestrator, execute steps 1-DOC.1 and 1-DOC.2\n2) Now, we need to prepare all the worker nodes. On each worker node, execute the following:\n2.1) Downlaod and unpack both the NodeEngine\nwget -c https://github.com/oakestra/oakestra/releases/download/v0.4.202/NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; mv NodeEngine NodeEngine_$(dpkg --print-architecture) \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\rand the NetManager\nwget -c https://github.com/oakestra/oakestra-net/releases/download/v0.4.202/NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r2.2) Edit /etc/netmanager/netcfg.json accordingly:\n{ \u0026#34;NodePublicAddress\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THIS DEVICE\u0026gt;\u0026#34;, \u0026#34;NodePublicPort\u0026#34;: \u0026#34;\u0026lt;PORT REACHABLE FROM OUTSIDE, internal port is always 50103\u0026gt;\u0026#34;, \u0026#34;ClusterUrl\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THE CLSUTER ORCHESTRATOR\u0026gt;\u0026#34;, \u0026#34;ClusterMqttPort\u0026#34;: \u0026#34;10003\u0026#34; }\r2.3) Run the NetManager and the NodeEngine components:\nsudo NetManager -p 6000 \u0026amp; sudo NodeEngine -n 6000 -p 10100 -a \u0026lt;IP ADDRESS OF THE CLSUTER ORCHESTRATOR\u0026gt;\rMDNC (M Devices, N Clusters) This represents the most versatile deployment. You can split your resources into multiple clusters within different locations and with different resources. In this deployment, we need to deploy the Root and the Cluster orchestrator on different nodes. Each independent clsuter orchestrator represents a cluster of resources. The worker nodes attached to each cluster are aggregated and seen as a unique big resource from the point of view of the Root. This deployment isolates the resources from the root perspective and delegates the responsibility to the cluster orchestrator. 1) In this first step, we need to deploy the RootOrchestrator component on a Node. To do this, you need to clone the repository on the desired node, move to the root orchestrator folder, and execute the startup command.\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra sudo -E docker-compose -f root_orchestrator/docker-compose-\u0026lt;arch\u0026gt;.yml up\r( please replace \u0026lt; arch \u0026gt; with your device architecture: arm or amd64 )\n2) For each node that needs to host a cluster orchestrator, you need to: 2.1) Export the ENV variables needed to connect to the cluster orchestrator:\nexport SYSTEM_MANAGER_URL=\u0026lt;IP ADDRESS OF THE NODE HOSTING THE ROOT ORCHESTRATOR\u0026gt; export CLUSTER_NAME=\u0026lt;choose a name for your cluster\u0026gt; export CLUSTER_LOCATION=\u0026lt;choose a name for the cluster\u0026#39;s location\u0026gt;\r2.2) Clone the repo and run the cluster orchestrator:\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra sudo -E docker-compose -f cluster_orchestrator/docker-compose-\u0026lt;arch\u0026gt;.yml up\r( please replace \u0026lt; arch \u0026gt; with your device architecture: arm or amd64 )\n3) Start and configure each worker as described in M-DOC.2\nHybrid Deployments You should have got the gist now, but if you want, you can build the infrastructure by composing the components like LEGO blocks. Do you want to give your Cluster Orchestrator computational capabilities for the deployment? Deploy an instance of NodeEngine + Netmanager components, and you\u0026rsquo;re done. You don\u0026rsquo;t want to use a separate node for the Root Orchestrator? Simply deploy it all together with a cluster orchestrator.\nWith Oakestra you can build your infrastructure as you like, and you can always scale it up or down as you need!\n","date":"0001-01-01","id":3,"permalink":"/docs/getting-started/deploy-your-first-oakestra-cluster/","summary":"Oakestra lets you deploy your workload on devices of any size. From a small RasperryPi to a cloud instance far away on GCP or AWS.","tags":[],"title":"Deploy your first Oakestra Cluster"},{"content":" Requirements\nYou have a running Oakestra deployment. You have at least one Worker Node registered (Optional) If you want the microservices to communicate, you need to have the NetManager installed and properly configured. You can access the APIs at \u0026lt;root-orch-ip\u0026gt;:10000/api/docs Let\u0026rsquo;s try deploying an Nginx server and a client. Then we\u0026rsquo;ll enter inside the client container and try to curl Nginx webserver.\nAll we need to do to deploy an application is to create a deployment descriptor and submit it to the platform using the APIs.\nDeployment Descriptor In order to deploy a container a deployment descriptor must be passed to the deployment command. The deployment descriptor contains all the information that Oakestra needs in order to achieve a complete deploy in the system.\nOakestra uses the following deployment descriptor format.\ndeploy_curl_application.yaml\r{ \u0026#34;sla_version\u0026#34; : \u0026#34;v2.0\u0026#34;, \u0026#34;customerID\u0026#34; : \u0026#34;Admin\u0026#34;, \u0026#34;applications\u0026#34; : [ { \u0026#34;applicationID\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;application_name\u0026#34; : \u0026#34;clientserver\u0026#34;, \u0026#34;application_namespace\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;application_desc\u0026#34; : \u0026#34;Simple demo with curl client and Nginx server\u0026#34;, \u0026#34;microservices\u0026#34; : [ { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;curl\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;tail -f /dev/null\u0026#34;], \u0026#34;memory\u0026#34;: 100, \u0026#34;vcpus\u0026#34;: 1, \u0026#34;vgpus\u0026#34;: 0, \u0026#34;vtpus\u0026#34;: 0, \u0026#34;bandwidth_in\u0026#34;: 0, \u0026#34;bandwidth_out\u0026#34;: 0, \u0026#34;storage\u0026#34;: 0, \u0026#34;code\u0026#34;: \u0026#34;docker.io/curlimages/curl:7.82.0\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;9080\u0026#34;, \u0026#34;added_files\u0026#34;: [] }, { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;cmd\u0026#34;: [], \u0026#34;memory\u0026#34;: 100, \u0026#34;vcpus\u0026#34;: 1, \u0026#34;vgpus\u0026#34;: 0, \u0026#34;vtpus\u0026#34;: 0, \u0026#34;bandwidth_in\u0026#34;: 0, \u0026#34;bandwidth_out\u0026#34;: 0, \u0026#34;storage\u0026#34;: 0, \u0026#34;code\u0026#34;: \u0026#34;docker.io/library/nginx:latest\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;6080:80/tcp\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.30.30\u0026#34; }, \u0026#34;added_files\u0026#34;: [] } ] } ] }\rSave this description as deploy_curl_application.yaml and upload it to the system using the APIs.\nThis deployment descriptor example generates one application named clientserver with the test namespace and two microservices:\nnginx server with test namespace, namely clientserver.test.nginx.test curl client with test namespace, namely clientserver.test.curl.test Learn more about the SLA specifications\rLogin to the APIs After running a cluster you can use the debug OpenAPI page at \u0026lt;root_orch_ip\u0026gt;:10000/api/docs to interact with the apis and use the infrastructure.\nAuthenticate using the following procedure:\nLocate the login method and use the try-out button Use the default Admin credentials to login\nusername: \u0026#34;Admin\u0026#34; password: \u0026#34;Admin\u0026#34;\rCopy the result login token Go to the top of the page and authenticate with this token Register an application and the services After you authenticate with the login function, you can try out to deploy the first application.\nUpload the deployment description to the system. You can try using the deployment descriptor above. The response contains the Application id and the id for all the application\u0026rsquo;s services. Now the application and the services are registered to the platform. It\u0026rsquo;s time to deploy the service instances!\nYou can always remove or create a new service for the application using the /api/services endpoints\nDeploy an instance of a registered service Trigger a deployment of a service\u0026rsquo;s instance using POST /api/service/{serviceid}/instance Each call to this endpoint generates a new instance of the service\nMonitor the service status With GET /api/aplications/\u0026lt;userid\u0026gt; (or simply /api/aplications/ if you\u0026rsquo;re admin) you can check the list of the deployed application. With GET /api/services/\u0026lt;appid\u0026gt; you can check the services attached to an application With GET /api/service/\u0026lt;serviceid\u0026gt; you can check the status for all the instances of \u0026lt;serviceid\u0026gt; Undeploy the service Use DELETE /api/service/\u0026lt;serviceid\u0026gt; to delete all the instances of a service Use DELETE /api/service/\u0026lt;serviceid\u0026gt;/instance/\u0026lt;instance number\u0026gt; to delete a specific instance of a service Use DELETE /api/application/\u0026lt;appid\u0026gt; to delete all together an application with all the services and instances Check if the service (un)deployment succeded Familiarize yourself with the API and discover for each one of the service the status and the public address.\nIf both services are ACTIVE, it is time to test the communication.\nIf either of the services are not ACTIVE, there might be a configuration issue or a bug. You can check the logs of the NetManager and NodeEngine components with docker logs system_manager -f --tail=1000 on the root orchestrator, with docker logs cluster_manager -f --tail=1000 on the cluster orchestrator. If unable to resolve, please open an issue on GitHub.\nTry to reach the nginx server you just deployed.\nhttp://\u0026lt;deployment_machine_ip\u0026gt;:6080\rIf you see the Nginx landing page, you just deployed your very first application with Oakestra! Hurray! ðŸŽ‰\n","date":"0001-01-01","id":4,"permalink":"/docs/getting-started/deploy-your-first-application/","summary":"Requirements\nYou have a running Oakestra deployment. You have at least one Worker Node registered (Optional) If you want the microservices to communicate, you need to have the NetManager installed and properly configured.","tags":[],"title":"Deploy your first Application"},{"content":"","date":"2023-09-07","id":5,"permalink":"/docs/guides/","summary":"","tags":[],"title":"Guides"},{"content":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\nFurther reading Read about how-to guides in the DiÃ¡taxis framework ","date":"2023-09-07","id":6,"permalink":"/docs/guides/example-guide/","summary":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.","tags":[],"title":"Example Guide"},{"content":"","date":"2023-09-07","id":7,"permalink":"/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"Application Deployment SLA The SLA deplyment descriptor is a JSON file that describes the deployment of an application in the Oakestra platform.\nAn example SLA of application X with two microservices X1 and X3 can be as follows.\n{ \u0026#34;sla_version\u0026#34; : \u0026#34;v2.0\u0026#34;, \u0026#34;customerID\u0026#34; : \u0026#34;Admin\u0026#34;, \u0026#34;applications\u0026#34; : [ { \u0026#34;applicationID\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;application_name\u0026#34; : \u0026#34;X\u0026#34;, \u0026#34;application_namespace\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;application_desc\u0026#34; : \u0026#34;X application\u0026#34;, \u0026#34;microservices\u0026#34; : [ { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;X1\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;vcpu\u0026#34;: 1, \u0026#34;storage\u0026#34;: 100, \u0026#34;code\u0026#34;: \u0026#34;docker.io/X/X1\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.0.1\u0026#34; }, }, { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;X3\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;vcpu\u0026#34;: 2, \u0026#34;storage\u0026#34;: 200, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;docker.io/X/X3\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.1.30\u0026#34; }, } ] } ] }\rFormat The file is composed of the following fields:\nsla_version: the current version customerID: id of the user, default is Admin application list, in a single deployment descriptor it is possible to define multiple applications, each containing: Fully qualified app name: A fully qualified name in Oakestra is composed of\napplication_name: unique name representing the application (max 10 char, no symbols) application_namespace: namespace of the app, used to reference different deployment of the same application. Examples of namespace name can be default or production or test (max 10 char, no symbols) applicationID: leave it empty for new deployments, this is needed only to edit an existing deployment. application_desc: Short description of the application\nmicroservice list is a list of the microservices composing the application. For each microservice the user can specify:\nmicroserviceID: leave it empty for new deployments, this is needed only to edit an existing deployment.\nFully qualified service name: Similar to applicattion name, it is composed of\nmicroservice_name: name of the service (max 10 char, no symbols) microservice_namespace: namespace of the service, used to reference different deployment of the same service. Examples of namespace name can be default or production or test (max 10 char, no symbols) virtualization: Starting with \u0026#x1fa97; Accordion v0.4.301, Oakestra supports both container and unikernel virtualization\ncmd: list of the commands to be executed inside the container at startup\nvcpu: minimum cpu vcores needed to run the container\nvgpu: minimum gpu vcores needed to run the container\nmemory: minimum memory amount needed to run the container\nstorage: minimum storage size required (currently the scheduler does not take this value into account)\nbandwidth_in/out: minimum required bandwith on the worker node. (currently the scheduler does not take this value into account)\nport: port mapping for the container in the syntax hostport_1:containerport_1[/protocol];hostport_2:containerport_2[/protocol] (default protocol is tcp)\naddresses: allows to specify a custom ip address to be used to balance the traffic across all the service instances.\nrr\\_ip: [optional filed] This field allows you to setup a custom Round Robin network address to reference all the instances belonging to this service. This address is going to be permanently bounded to the service. The address MUST be in the form 10.30.x.y and must not collide with any other Instance Address or Service IP in the system, otherwise an error will be returned. If you don\u0026rsquo;t specify a RR_ip and you don\u0026rsquo;t set this field, a new address will be generated by the system. constraints: array of constraints regarding the service.\ntype: constraint type direct: Send a deployment to a specific cluster and a specific list of eligible nodes. You can specify \u0026quot;node\u0026quot;:\u0026quot;node1;node2;...;noden\u0026quot; a list of node\u0026rsquo;s hostnames. These are the only eligible worker nodes. \u0026quot;cluster\u0026quot;:\u0026quot;cluster_name\u0026quot; The name of the cluster where this service must be scheduled. E.g.: \u0026#34;constraints\u0026#34;:[\r{\r\u0026#34;type\u0026#34;:\u0026#34;direct\u0026#34;,\r\u0026#34;node\u0026#34;:\u0026#34;xavier1\u0026#34;,\r\u0026#34;cluster\u0026#34;:\u0026#34;gpu\u0026#34;\r}\r]\r","date":"2023-09-07","id":8,"permalink":"/docs/reference/application-sla-description/","summary":"Application Deployment SLA The SLA deplyment descriptor is a JSON file that describes the deployment of an application in the Oakestra platform.","tags":[],"title":"Application SLA Description"},{"content":"","date":"2023-09-07","id":9,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":10,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":11,"permalink":"/","summary":"","tags":[],"title":"Oakestra"},{"content":"","date":"0001-01-01","id":12,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":13,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":14,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]