[{"content":"Well-thought-through product announcements will help increase feature awareness and engage users with new functionality. Just like sharing your public roadmap, it\u0026rsquo;s also a great way to let potential customers see that you\u0026rsquo;re constantly improving.\nFurther reading Read How to announce product updates and features ","date":"2023-09-07","id":0,"permalink":"/blog/example-post/","summary":"You can use blog posts for announcing product updates and features.","tags":[],"title":"Example Post"},{"content":"","date":"2023-09-07","id":1,"permalink":"/blog/","summary":"","tags":[],"title":"Blog"},{"content":"","date":"2023-09-07","id":2,"permalink":"/docs/getting-started/","summary":"","tags":[],"title":"Getting Started"},{"content":"\rOakestra lets you deploy your workload on devices of any size. From a small RasperryPi to a cloud instance far away on GCP or AWS. The tree structure enables you to create multiple clusters of resources.\nThe Root Orchestrator manages different clusters of resources. The root only sees aggregated cluster resources. The Cluster orchestrator manages your worker nodes. This component collects the real-time resources and schedules your workloads to the perfect matching device. A Worker is any device where a component called NodeEngine is installed. Each node can support multiple execution environments such as Containers (containerd runtime), MicroVM (containerd runtime), and Unikernels (mirageOS). Did you know?\nSince the stable Accordion release, Oakestra supports both containers and unikernel virtualization targets.\nCreate your first Oakestra cluster Let\u0026rsquo;s start simple with a single node deployment, where all the components are deployed on the same device.\nRequirements\nLinux (Workers only) Docker + Docker compose (Orchestrators only) Cluster Orchestrator and Root Orchestrator machines must be mutually reachable. 1-DOC (1 Device, One Cluster) In this example, we will use a single device to deploy all the components. This is not recommended for production environments, but it is pretty cool for home environments and development.\n0) First, let\u0026rsquo;s export the required environment variables\n## Choose a unique name for your cluster export CLUSTER_NAME=My_Awesome_Cluster ## Come up with a name for the current location export CLUSTER_LOCATION=My_Awesome_Apartment\r1) Clone the repository and move into it using:\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra\r2) Run a local 1-DOC cluster\nsudo -E docker-compose -f run-a-cluster/1-DOC.yaml up\r3) download, untar and install the node engine package\nwget -c https://github.com/oakestra/oakestra/releases/download/v0.4.202/NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; mv NodeEngine NodeEngine_$(dpkg --print-architecture) \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r4) (optional) download and unzip and install the network manager; this enables an overlay network across your services\nwget -c https://github.com/oakestra/oakestra-net/releases/download/v0.4.202/NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r4.1) Edit /etc/netmanager/netcfg.json as follows:\n{ \u0026#34;NodePublicAddress\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THIS DEVICE\u0026gt;\u0026#34;, \u0026#34;NodePublicPort\u0026#34;: \u0026#34;\u0026lt;PORT REACHABLE FROM OUTSIDE, use 50103 as default\u0026gt;\u0026#34;, \u0026#34;ClusterUrl\u0026#34;: \u0026#34;localhost\u0026#34;, \u0026#34;ClusterMqttPort\u0026#34;: \u0026#34;10003\u0026#34; }\r4.2) start the NetManager on port 6000\nsudo NetManager -p 6000 \u0026amp;\r5) start the NodeEngine. Please only use the -n 6000 parameter if you started the network component in step 4. This parameter, in fact, is used to specify the internal port of the network component, if any.\nsudo NodeEngine -n 6000 -p 10100\r( you can use NodeEngine -h for further details )\nM-DOC (M Devices, One Cluster) Now, let\u0026rsquo;s separate the Oakestra components over multiple devices and create a more distributed cluster.\nThe M-DOC deployment enables you to deploy One cluster with multiple worker nodes. The main difference between this deployment and 1-DOC is that the worker nodes might be external here, and there can be multiple of them.\nThe deployment of this kind of cluster is similar to 1-DOC. We first need to start the root and cluster orchestrator. Afterward, we can attach the worker nodes.\n1) On the node you wish to use as a cluster and root orchestrator, execute steps 1-DOC.1 and 1-DOC.2\n2) Now, we need to prepare all the worker nodes. On each worker node, execute the following:\n2.1) Downlaod and unpack both the NodeEngine\nwget -c https://github.com/oakestra/oakestra/releases/download/v0.4.202/NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NodeEngine_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; mv NodeEngine NodeEngine_$(dpkg --print-architecture) \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\rand the NetManager\nwget -c https://github.com/oakestra/oakestra-net/releases/download/v0.4.202/NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; tar -xzf NetManager_$(dpkg --print-architecture).tar.gz \u0026amp;\u0026amp; chmod +x install.sh \u0026amp;\u0026amp; ./install.sh $(dpkg --print-architecture)\r2.2) Edit /etc/netmanager/netcfg.json accordingly:\n{ \u0026#34;NodePublicAddress\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THIS DEVICE\u0026gt;\u0026#34;, \u0026#34;NodePublicPort\u0026#34;: \u0026#34;\u0026lt;PORT REACHABLE FROM OUTSIDE, internal port is always 50103\u0026gt;\u0026#34;, \u0026#34;ClusterUrl\u0026#34;: \u0026#34;\u0026lt;IP ADDRESS OF THE CLSUTER ORCHESTRATOR\u0026gt;\u0026#34;, \u0026#34;ClusterMqttPort\u0026#34;: \u0026#34;10003\u0026#34; }\r2.3) Run the NetManager and the NodeEngine components:\nsudo NetManager -p 6000 \u0026amp; sudo NodeEngine -n 6000 -p 10100 -a \u0026lt;IP ADDRESS OF THE CLSUTER ORCHESTRATOR\u0026gt;\rMDNC (M Devices, N Clusters) This represents the most versatile deployment. You can split your resources into multiple clusters within different locations and with different resources. In this deployment, we need to deploy the Root and the Cluster orchestrator on different nodes. Each independent clsuter orchestrator represents a cluster of resources. The worker nodes attached to each cluster are aggregated and seen as a unique big resource from the point of view of the Root. This deployment isolates the resources from the root perspective and delegates the responsibility to the cluster orchestrator. 1) In this first step, we need to deploy the RootOrchestrator component on a Node. To do this, you need to clone the repository on the desired node, move to the root orchestrator folder, and execute the startup command.\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra sudo -E docker-compose -f root_orchestrator/docker-compose-\u0026lt;arch\u0026gt;.yml up\r( please replace \u0026lt; arch \u0026gt; with your device architecture: arm or amd64 )\n2) For each node that needs to host a cluster orchestrator, you need to: 2.1) Export the ENV variables needed to connect to the cluster orchestrator:\nexport SYSTEM_MANAGER_URL=\u0026lt;IP ADDRESS OF THE NODE HOSTING THE ROOT ORCHESTRATOR\u0026gt; export CLUSTER_NAME=\u0026lt;choose a name for your cluster\u0026gt; export CLUSTER_LOCATION=\u0026lt;choose a name for the cluster\u0026#39;s location\u0026gt;\r2.2) Clone the repo and run the cluster orchestrator:\ngit clone https://github.com/oakestra/oakestra.git \u0026amp;\u0026amp; cd oakestra sudo -E docker-compose -f cluster_orchestrator/docker-compose-\u0026lt;arch\u0026gt;.yml up\r( please replace \u0026lt; arch \u0026gt; with your device architecture: arm or amd64 )\n3) Start and configure each worker as described in M-DOC.2\nHybrid Deployments You should have got the gist now, but if you want, you can build the infrastructure by composing the components like LEGO blocks. Do you want to give your Cluster Orchestrator computational capabilities for the deployment? Deploy an instance of NodeEngine + Netmanager components, and you\u0026rsquo;re done. You don\u0026rsquo;t want to use a separate node for the Root Orchestrator? Simply deploy it all together with a cluster orchestrator.\nWith Oakestra you can build your infrastructure as you like, and you can always scale it up or down as you need!\n","date":"0001-01-01","id":3,"permalink":"/docs/getting-started/deploy-your-first-oakestra-cluster/","summary":"Oakestra lets you deploy your workload on devices of any size. From a small RasperryPi to a cloud instance far away on GCP or AWS.","tags":[],"title":"Deploy your first Oakestra Cluster"},{"content":"","date":"2023-09-07","id":4,"permalink":"/docs/getting-started/deploy-app/","summary":"","tags":[],"title":"Deploy your first App"},{"content":"\rRequirements\nYou have a running Oakestra deployment. You have at least one Worker Node registered (Optional) If you want the microservices to communicate, you need to have the NetManager installed and properly configured. You can access the APIs at \u0026lt;root-orch-ip\u0026gt;:10000/api/docs Let\u0026rsquo;s try deploying an Nginx server and a client. Then we\u0026rsquo;ll enter inside the client container and try to curl Nginx webserver.\nAll we need to do to deploy an application is to create a deployment descriptor and submit it to the platform using the APIs.\nDeployment Descriptor In order to deploy a container a deployment descriptor must be passed to the deployment command. The deployment descriptor contains all the information that Oakestra needs in order to achieve a complete deploy in the system.\nOakestra uses the following deployment descriptor format.\ndeploy_curl_application.yaml\r{ \u0026#34;sla_version\u0026#34; : \u0026#34;v2.0\u0026#34;, \u0026#34;customerID\u0026#34; : \u0026#34;Admin\u0026#34;, \u0026#34;applications\u0026#34; : [ { \u0026#34;applicationID\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;application_name\u0026#34; : \u0026#34;clientserver\u0026#34;, \u0026#34;application_namespace\u0026#34; : \u0026#34;test\u0026#34;, \u0026#34;application_desc\u0026#34; : \u0026#34;Simple demo with curl client and Nginx server\u0026#34;, \u0026#34;microservices\u0026#34; : [ { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;curl\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;cmd\u0026#34;: [\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;tail -f /dev/null\u0026#34;], \u0026#34;memory\u0026#34;: 100, \u0026#34;vcpus\u0026#34;: 1, \u0026#34;vgpus\u0026#34;: 0, \u0026#34;vtpus\u0026#34;: 0, \u0026#34;bandwidth_in\u0026#34;: 0, \u0026#34;bandwidth_out\u0026#34;: 0, \u0026#34;storage\u0026#34;: 0, \u0026#34;code\u0026#34;: \u0026#34;docker.io/curlimages/curl:7.82.0\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;9080\u0026#34;, \u0026#34;added_files\u0026#34;: [] }, { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;nginx\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;cmd\u0026#34;: [], \u0026#34;memory\u0026#34;: 100, \u0026#34;vcpus\u0026#34;: 1, \u0026#34;vgpus\u0026#34;: 0, \u0026#34;vtpus\u0026#34;: 0, \u0026#34;bandwidth_in\u0026#34;: 0, \u0026#34;bandwidth_out\u0026#34;: 0, \u0026#34;storage\u0026#34;: 0, \u0026#34;code\u0026#34;: \u0026#34;docker.io/library/nginx:latest\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;port\u0026#34;: \u0026#34;6080:80/tcp\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.30.30\u0026#34; }, \u0026#34;added_files\u0026#34;: [] } ] } ] }\rSave this description as deploy_curl_application.yaml and upload it to the system using the APIs.\nThis deployment descriptor example generates one application named clientserver with the test namespace and two microservices:\nnginx server with test namespace, namely clientserver.test.nginx.test curl client with test namespace, namely clientserver.test.curl.test Learn more about the SLA specifications\rLogin to the APIs After running a cluster you can use the debug OpenAPI page at \u0026lt;root_orch_ip\u0026gt;:10000/api/docs to interact with the apis and use the infrastructure.\nAuthenticate using the following procedure:\nLocate the login method and use the try-out button Use the default Admin credentials to login\nusername: \u0026#34;Admin\u0026#34; password: \u0026#34;Admin\u0026#34;\rCopy the result login token Go to the top of the page and authenticate with this token Register an application and the services After you authenticate with the login function, you can try out to deploy the first application.\nUpload the deployment description to the system. You can try using the deployment descriptor above. The response contains the Application id and the id for all the application\u0026rsquo;s services. Now the application and the services are registered to the platform. It\u0026rsquo;s time to deploy the service instances!\nYou can always remove or create a new service for the application using the /api/services endpoints\nDeploy an instance of a registered service Trigger a deployment of a service\u0026rsquo;s instance using POST /api/service/{serviceid}/instance Each call to this endpoint generates a new instance of the service\nMonitor the service status With GET /api/aplications/\u0026lt;userid\u0026gt; (or simply /api/aplications/ if you\u0026rsquo;re admin) you can check the list of the deployed application. With GET /api/services/\u0026lt;appid\u0026gt; you can check the services attached to an application With GET /api/service/\u0026lt;serviceid\u0026gt; you can check the status for all the instances of \u0026lt;serviceid\u0026gt; Undeploy the service Use DELETE /api/service/\u0026lt;serviceid\u0026gt; to delete all the instances of a service Use DELETE /api/service/\u0026lt;serviceid\u0026gt;/instance/\u0026lt;instance number\u0026gt; to delete a specific instance of a service Use DELETE /api/application/\u0026lt;appid\u0026gt; to delete all together an application with all the services and instances Check if the service (un)deployment succeeded Familiarize yourself with the API and discover for each one of the service the status and the public address.\nIf both services are ACTIVE, it is time to test the communication.\nIf either of the services are not ACTIVE, there might be a configuration issue or a bug. You can check the logs of the NetManager and NodeEngine components with docker logs system_manager -f --tail=1000 on the root orchestrator, with docker logs cluster_manager -f --tail=1000 on the cluster orchestrator. If unable to resolve, please open an issue on GitHub.\nTry to reach the nginx server you just deployed.\nhttp://\u0026lt;deployment_machine_ip\u0026gt;:6080\rIf you see the Nginx landing page, you just deployed your very first application with Oakestra! Hurray! 🎉\n","date":"2023-09-07","id":5,"permalink":"/docs/getting-started/deploy-app/with-the-api/","summary":"Requirements\nYou have a running Oakestra deployment. You have at least one Worker Node registered (Optional) If you want the microservices to communicate, you need to have the NetManager installed and properly configured.","tags":[],"title":"With the API"},{"content":"The Dashboard Now that you have familiarized yourself with the API, you can try out the dashboard. The dashboard is the front-end component to cluster management.\nIt allows the user to:\nView the applications currently running on the cluster Create and modify individual services Check the status of running services Configure service-level agreements (SLAs) Deployment Requirements\nYou have a running Root Orchestrator. You can access the APIs at \u0026lt;IP_OF_CLUSTER_ORCHESTRATOR\u0026gt;:10000 If you deployed your cluster with one of the provided docker-compose files, this has already been done for you and you can simply head over to \u0026lt;http://IP_OF_CLUSTER_ORCHESTRATOR\u0026gt;. Otherwise follow the instructions below.\nManual deployment: 0) Clone the repository\ngit clone https://github.com/oakestra/dashboard.git \u0026amp;\u0026amp; cd dashboard\r1) Create a file that contains the environment variables\necho \u0026#34;API_ADDRESS=\u0026lt;IP_OF_CLUSTER_ORCHESTRATOR\u0026gt;:10000\u0026#34; \u0026gt; .env\r2) Run the dashboard\nsudo docker-compose up\rRunning the Oakestra Framework To be able to log into the dashboard, the System Manager and MongoDB must be started. How this can be done is described in the getting started section.\nIf these components were not started or improperly configured, the login screen can be reached, but you cannot log in to the dashboard.\nAccessing the dashboard Now that the dashboard is up and running, let\u0026rsquo;s log in and explore its functionality. Upon launching the system for the first time, an administrative user is automatically created. This user can create and manage other users and organizations within the system, more on User Management later.\nAdmin Credentials\nUsername: Admin\nPassword: Admin\nChange the Password\nAfter setting up the cluster manager immediately change the password of the admin user!\nOrganization Login To log in to an organization check the Organization login box and enter the organization name. If the box is not checked or the organization name is left empty, then you will logged in to the default root organization.\nOrganizations\rMore on organizations\nHere you can see the login to the sampleOrga:\nApplications, Services, Namespaces In Oakestra there are applications, services and namespaces. One Application can encompass multiple services and one user can create multiple applications on one system. Namespaces allow you to create applications and services by the same name in different namespaces, e.g. production and development.\nCreating an Application First you will have to create an application. Choose a concise name, the namespace and optionally a description.\nCreating a Service In the previous section we discussed registering deployment descriptors via the API. This is great for automated deployments, but the SLAs were not designed with human readability in mind. While the dashboard still allows you to upload SLAs as a JSON file, it also provides you with an interactive form.\nOnce you have created an application you can create services. Once again you will have to choose a concise name, a namespace and optionally a description. However this is far from it; system requirements, environmental variables, connection details and much more can be specified here.\nYou will have to choose a virtualization method (Container or Unikernel) and tell Oakestra where it can find your code. Hit save and your service is ready for deployment!\nService Details Once a service has been created and deployed, you can check on it\u0026rsquo;s status and other details. Choose a service from the Service List and from the drop-down menu, choose an instance and click on View Instance Details.\nSomething Missing?\nIf you have any new feature ideas or if you find any bugs please open an issue in the GitHub repository.\n","date":"2023-09-07","id":6,"permalink":"/docs/getting-started/deploy-app/with-the-dashboard/","summary":"The Dashboard Now that you have familiarized yourself with the API, you can try out the dashboard. The dashboard is the front-end component to cluster management.","tags":[],"title":"With the Dashboard"},{"content":"","date":"2023-09-07","id":7,"permalink":"/docs/getting-started/deploy-app/with-the-cli/","summary":"","tags":[],"title":"With the CLI"},{"content":"","date":"2023-09-07","id":8,"permalink":"/docs/concepts/","summary":"","tags":[],"title":"Concepts"},{"content":"","date":"0001-01-01","id":9,"permalink":"/docs/concepts/high-level-architecture/","summary":"","tags":[],"title":"High Level Architecture"},{"content":"","date":"0001-01-01","id":10,"permalink":"/docs/concepts/orchestration/","summary":"","tags":[],"title":"Orchestration"},{"content":"","date":"0001-01-01","id":11,"permalink":"/docs/concepts/scheduling/","summary":"","tags":[],"title":"Scheduling"},{"content":"","date":"0001-01-01","id":12,"permalink":"/docs/concepts/networking/","summary":"","tags":[],"title":"Networking"},{"content":"","date":"2023-09-07","id":13,"permalink":"/docs/concepts/features/","summary":"","tags":[],"title":"Features"},{"content":"","date":"0001-01-01","id":14,"permalink":"/docs/concepts/features/performance/","summary":"","tags":[],"title":"Performance"},{"content":"","date":"0001-01-01","id":15,"permalink":"/docs/concepts/features/heterogeneity/","summary":"","tags":[],"title":"Heterogeneity"},{"content":"","date":"2023-09-07","id":16,"permalink":"/docs/manuals/","summary":"","tags":[],"title":"Manuals"},{"content":"","date":"0001-01-01","id":17,"permalink":"/docs/manuals/unikernel-operations/","summary":"","tags":[],"title":"Unikernel Operations"},{"content":"","date":"0001-01-01","id":18,"permalink":"/docs/manuals/kubernetes-integration/","summary":"","tags":[],"title":"Kubernetes Integration"},{"content":"","date":"2023-09-07","id":19,"permalink":"/docs/manuals/networking-internals/","summary":"","tags":[],"title":"Networking Internals"},{"content":"","date":"0001-01-01","id":20,"permalink":"/docs/manuals/networking-internals/semantic-addressing/","summary":"","tags":[],"title":"Semantic Addressing"},{"content":"","date":"0001-01-01","id":21,"permalink":"/docs/manuals/networking-internals/ipv4-addressing/","summary":"","tags":[],"title":"IPv4 Addressing"},{"content":"","date":"0001-01-01","id":22,"permalink":"/docs/manuals/networking-internals/ipv6-addressing/","summary":"","tags":[],"title":"IPv6 Addressing"},{"content":"","date":"0001-01-01","id":23,"permalink":"/docs/manuals/networking-internals/gateway-operations/","summary":"","tags":[],"title":"Gateway Operations"},{"content":"","date":"2023-09-07","id":24,"permalink":"/docs/manuals/dashboard-features/","summary":"","tags":[],"title":"Dashboard Features"},{"content":"Organizations We briefly mentioned organizations previously, now let\u0026rsquo;s take a closer look at them. Organizations facilitate collaboration amongst team members by providing:\nA collaborative Space: All applications within an organization are visible to all team members Resource Utilization: Resources are shared within an organization Access Control: Easily grant a new team member access to your applications and resources by adding them to your organization The Root Organization A user can be a member of multiple organizations, but they are all a member of the root organization. This is the default organization that is created when a root orchestrator is started, it is also the organization that you sign in to when you do not select organization login. Unlike other organizations, applications and resources are not shared and are only available to the user that created them.\nUser Management Different team members have different tasks that require different permissions, so it makes sense to assign them roles based on which permissions they require to do their work.\nRoles Admin: Can add new users to an organization and manage their roles. This is the role of the default user Organization Admin: Can add new users to an organization and manage their roles Infrastructure Provider: Can add resources to the organization Application Provider: The default role of a user, can manage and deploy applications on organization resources ","date":"0001-01-01","id":25,"permalink":"/docs/manuals/dashboard-features/organizations/","summary":"Organizations We briefly mentioned organizations previously, now let\u0026rsquo;s take a closer look at them. Organizations facilitate collaboration amongst team members by providing:","tags":[],"title":"Organizations"},{"content":"","date":"0001-01-01","id":26,"permalink":"/docs/manuals/dashboard-features/email-configuration/","summary":"","tags":[],"title":"Email Configuration"},{"content":"","date":"2023-09-07","id":27,"permalink":"/docs/manuals/cli-features/","summary":"","tags":[],"title":"CLI Features"},{"content":"","date":"0001-01-01","id":28,"permalink":"/docs/manuals/cli-features/features/","summary":"","tags":[],"title":"Features"},{"content":"","date":"2023-09-07","id":29,"permalink":"/docs/manuals/debugging/","summary":"","tags":[],"title":"Debugging"},{"content":"","date":"0001-01-01","id":30,"permalink":"/docs/manuals/debugging/networking/","summary":"","tags":[],"title":"Networking"},{"content":"","date":"0001-01-01","id":31,"permalink":"/docs/manuals/debugging/control-plane/","summary":"","tags":[],"title":"Control Plane"},{"content":"","date":"0001-01-01","id":32,"permalink":"/docs/manuals/debugging/unikernels/","summary":"","tags":[],"title":"Unikernels"},{"content":"","date":"2023-09-07","id":33,"permalink":"/docs/contribution-guide/","summary":"","tags":[],"title":"Contributing Guide"},{"content":"","date":"0001-01-01","id":34,"permalink":"/docs/contribution-guide/code-of-conduct/","summary":"","tags":[],"title":"Code of Conduct"},{"content":"","date":"0001-01-01","id":35,"permalink":"/docs/contribution-guide/commit-hooks/","summary":"","tags":[],"title":"Commit Hooks"},{"content":"","date":"0001-01-01","id":36,"permalink":"/docs/contribution-guide/language-guide/","summary":"","tags":[],"title":"Language Guide"},{"content":"","date":"2023-09-07","id":37,"permalink":"/docs/guides/","summary":"","tags":[],"title":"Guides"},{"content":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.\nFurther reading Read about how-to guides in the Diátaxis framework ","date":"2023-09-07","id":38,"permalink":"/docs/guides/example-guide/","summary":"Guides lead a user through a specific task they want to accomplish, often with a sequence of steps. Writing a good guide requires thinking about what your users are trying to do.","tags":[],"title":"Example Guide"},{"content":"","date":"2023-09-07","id":39,"permalink":"/docs/reference/","summary":"","tags":[],"title":"Reference"},{"content":"Application Deployment SLA The SLA deplyment descriptor is a JSON file that describes the deployment of an application in the Oakestra platform.\nAn example SLA of application X with two microservices X1 and X3 can be as follows.\n{ \u0026#34;sla_version\u0026#34; : \u0026#34;v2.0\u0026#34;, \u0026#34;customerID\u0026#34; : \u0026#34;Admin\u0026#34;, \u0026#34;applications\u0026#34; : [ { \u0026#34;applicationID\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;application_name\u0026#34; : \u0026#34;X\u0026#34;, \u0026#34;application_namespace\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;application_desc\u0026#34; : \u0026#34;X application\u0026#34;, \u0026#34;microservices\u0026#34; : [ { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;X1\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;vcpu\u0026#34;: 1, \u0026#34;storage\u0026#34;: 100, \u0026#34;code\u0026#34;: \u0026#34;docker.io/X/X1\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.0.1\u0026#34; }, }, { \u0026#34;microserviceID\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;microservice_name\u0026#34;: \u0026#34;X3\u0026#34;, \u0026#34;microservice_namespace\u0026#34;: \u0026#34;default\u0026#34;, \u0026#34;vcpu\u0026#34;: 2, \u0026#34;storage\u0026#34;: 200, \u0026#34;virtualization\u0026#34;: \u0026#34;container\u0026#34;, \u0026#34;code\u0026#34;: \u0026#34;docker.io/X/X3\u0026#34;, \u0026#34;addresses\u0026#34;: { \u0026#34;rr_ip\u0026#34;: \u0026#34;10.30.1.30\u0026#34; }, } ] } ] }\rFormat The file is composed of the following fields:\nsla_version: the current version customerID: id of the user, default is Admin application list, in a single deployment descriptor it is possible to define multiple applications, each containing: Fully qualified app name: A fully qualified name in Oakestra is composed of\napplication_name: unique name representing the application (max 10 char, no symbols) application_namespace: namespace of the app, used to reference different deployment of the same application. Examples of namespace name can be default or production or test (max 10 char, no symbols) applicationID: leave it empty for new deployments, this is needed only to edit an existing deployment. application_desc: Short description of the application\nmicroservice list is a list of the microservices composing the application. For each microservice the user can specify:\nmicroserviceID: leave it empty for new deployments, this is needed only to edit an existing deployment.\nFully qualified service name: Similar to applicattion name, it is composed of\nmicroservice_name: name of the service (max 10 char, no symbols) microservice_namespace: namespace of the service, used to reference different deployment of the same service. Examples of namespace name can be default or production or test (max 10 char, no symbols) virtualization: Starting with \u0026#x1fa97; Accordion v0.4.301, Oakestra supports both container and unikernel virtualization\ncmd: list of the commands to be executed inside the container at startup\nvcpu: minimum cpu vcores needed to run the container\nvgpu: minimum gpu vcores needed to run the container\nmemory: minimum memory amount needed to run the container\nstorage: minimum storage size required (currently the scheduler does not take this value into account)\nbandwidth_in/out: minimum required bandwith on the worker node. (currently the scheduler does not take this value into account)\nport: port mapping for the container in the syntax hostport_1:containerport_1[/protocol];hostport_2:containerport_2[/protocol] (default protocol is tcp)\naddresses: allows to specify a custom ip address to be used to balance the traffic across all the service instances.\nrr\\_ip: [optional filed] This field allows you to setup a custom Round Robin network address to reference all the instances belonging to this service. This address is going to be permanently bounded to the service. The address MUST be in the form 10.30.x.y and must not collide with any other Instance Address or Service IP in the system, otherwise an error will be returned. If you don\u0026rsquo;t specify a RR_ip and you don\u0026rsquo;t set this field, a new address will be generated by the system. constraints: array of constraints regarding the service.\ntype: constraint type direct: Send a deployment to a specific cluster and a specific list of eligible nodes. You can specify \u0026quot;node\u0026quot;:\u0026quot;node1;node2;...;noden\u0026quot; a list of node\u0026rsquo;s hostnames. These are the only eligible worker nodes. \u0026quot;cluster\u0026quot;:\u0026quot;cluster_name\u0026quot; The name of the cluster where this service must be scheduled. E.g.: \u0026#34;constraints\u0026#34;:[\r{\r\u0026#34;type\u0026#34;:\u0026#34;direct\u0026#34;,\r\u0026#34;node\u0026#34;:\u0026#34;xavier1\u0026#34;,\r\u0026#34;cluster\u0026#34;:\u0026#34;gpu\u0026#34;\r}\r]\r","date":"2023-09-07","id":40,"permalink":"/docs/reference/application-sla-description/","summary":"Application Deployment SLA The SLA deplyment descriptor is a JSON file that describes the deployment of an application in the Oakestra platform.","tags":[],"title":"Application SLA Description"},{"content":"","date":"2023-09-07","id":41,"permalink":"/docs/","summary":"","tags":[],"title":"Docs"},{"content":"","date":"2023-09-07","id":42,"permalink":"/privacy/","summary":"","tags":[],"title":"Privacy Policy"},{"content":"","date":"2023-09-07","id":43,"permalink":"/","summary":"","tags":[],"title":"Oakestra"},{"content":"","date":"0001-01-01","id":44,"permalink":"/categories/","summary":"","tags":[],"title":"Categories"},{"content":"","date":"0001-01-01","id":45,"permalink":"/contributors/","summary":"","tags":[],"title":"Contributors"},{"content":"","date":"0001-01-01","id":46,"permalink":"/tags/","summary":"","tags":[],"title":"Tags"}]